---
title: 建站测试
date: 2022-09-23 22:36:04
tags: -乱七八糟
mathjax: true
---

## 题解 · 斐波那契公约数 

#### 题目描述：

求斐波那契数列第n项和第m项的最大公约数。

#### 解题思路：

首先看到这道题，斐波那契数列，递归就可以；最大公约数，算法也很简单，加在一起，直觉有坑。

再一看题，$1\le n,m\le 10^{9}$ ，直接递归直接算肯定不行。

我们再来研究一下题目~~（就喜欢这种题目描述非常短又很有意思的题）~~。

斐波那契数列，很有规律，$f(n)=f(n-1)+f(n-2)$ ；最大公约数，也有很多性质，加在一起，应该也会有一些有趣的结论吧。

 ~~也许可以试试打表找规律,反正我是直接看了结论，不过这种看起来就很漂亮的结论证起来还是很有意思的~~ 

***结论：***$gcd(f(n),f(m))=f(gcd(n,m))$

要证明这个得先有几个预备知识：

1. 斐波那契数列$f(n)=\{0,1,1,2,3,5,\dots\}(n\ge 0)$。
2. $gcd(x,y)=gcd(x,y-x)\Rightarrow gcd(x,y)=gcd(x,y\%x)$。
3. $gcd(a,kb)=gcd(a,k)(a,b互质，即gcd(a,b)=1)$。
4. $gcd(0,x)=x$。
5. 求$gcd(x,y)$的方法：辗转相除法。

好了这样，我们就可以证明了。

***证明：***不妨设 $n<m$ .

​			根据*预备知识2*，有
$$
\begin{equation}
\begin{aligned}
gcd(f(n),f(n+1))&=gcd(f(n),f(n+1)-f(n))=gcd(f(n),f(n-1))\\
&=gcd(f(n-1),f(n)-f(n-1))=gcd(f(n-1),f(n-2))\\
&=gcd(f(n-2),f(n-1)-f(n-2))=gcd(f(n-2),f(n-3))\\
&=\dots\\
&=gcd(f(2),f(1))=gcd(1,1)=1\\
\therefore f(n)与f(n+1)互质
\end{aligned}
\end{equation}
$$

​		设$f(n)=a,f(n+1)=b$，那么
$$
f(n+2)=a+b\\
f(n+3)=a+2b\\
f(n+4)=2a+3b\\
\dots
$$
​		不难发现，$a、b$的系数分别依次构成斐波那契数列的子序列，且
$$
f(n+k)=f(k-1)a+f(k)b\\
\therefore f(m)=f(m-n-1)a+f(m-n)b=f(m-n-1)f(n)+f(m-n)f(n+1)
$$
​		这样就有
$$
\begin{equation}
\begin{aligned}
gcd(f(n),f(m))&=gcd(f(n),f(m-n-1)f(n)+f(m-n)f(n+1))\\
&=gcd(f(n),f(m-n)f(n+1))(预备知识2)\\
&=gcd(f(n),f(m-n))(预备知识3)\\
&=gcd(f(n),f(m\%n))\\
&=gcd(f(n),f(m_{1}))(令m_{1}=m\%n)\\
&=gcd(f(n\%m_{1}),f(m_{1}))\\
&=gcd(f(m_{2}),f(m_{1}))(令m_{2}=n\%m_{1})\\
&=\dots (不难发现这其实是在对n,m辗转相除)\\
&=gcd(f(0),f(gcd(n,m)))\\
&=gcd(0,f(gcd(n,m)))\\
&=f(gcd(n,m))(预备知识4)\\
\therefore gcd(f(n),f(m))=f(gcd(n,m))
\end{aligned}
\end{equation}
$$
证完之后，只有这个结论还不行啊，数据这么大，直接递归求斐波那契数列肯定不行。

所以第二个问题：***求斐波那契数列的方法——矩阵快速幂***

快速幂就不说了，我们先来构造矩阵。

根据斐波那契数列奇妙的性质，有
$$
\begin{pmatrix}
f(n),f(n+1)
\end{pmatrix}
\begin{pmatrix}
0 & 1\\1 & 1
\end{pmatrix}
=
\begin{pmatrix}
f(n+1),f(n+2)
\end{pmatrix}
\\\therefore
\begin{pmatrix}
f(1),f(2)
\end{pmatrix}
\begin{pmatrix}
0 & 1\\1 & 1
\end{pmatrix}
^{n-1}=
\begin{pmatrix}
f(n),f(n+1)
\end{pmatrix}
\\\therefore
\begin{pmatrix}
f(n),f(n+1)
\end{pmatrix}
=
\begin{pmatrix}
1,1
\end{pmatrix}
\begin{pmatrix}
0 & 1\\1 & 1
\end{pmatrix}^{n-1}
$$
这样求斐波那契数列的第$n$项就转化成求矩阵$n-1$次幂的问题，矩阵快速幂实现就可以。

#### AC代码：

最后附上我的$cpp$代码：

```c++
#include <iostream>
using namespace std;

struct matrix
{
	long long m[2][2];
};

long long gcd(long long x,long long y)
{
	long long r=x%y;
	while(r)
	{
		x=y;
		y=r;
		r=x%y;
	}
	return y;
}

matrix mul(matrix a,matrix b)
{
	matrix c;
	c.m[0][0]=0;
	c.m[0][1]=0;
	c.m[1][0]=0;
	c.m[1][1]=0;
	for(int i=0;i<2;i++)
	{
		for(int j=0;j<2;j++)
		{
			for(int k=0;k<2;k++)
			{
				c.m[i][j]+=a.m[i][k]*b.m[k][j];	
				c.m[i][j]%=100000000;
			}	
		}
	}
	return c;
}

long long f(long long n)
{
	matrix a,e;	
	long long k=n;
	a.m[0][0]=0;
	a.m[0][1]=1;
	a.m[1][0]=1;
	a.m[1][1]=1;
	e.m[0][0]=1;
	e.m[0][1]=0;
	e.m[1][0]=0;
	e.m[1][1]=1;
	while(k)
	{
		if(k&1) e=mul(e,a);
		a=mul(a,a);
		k=k/2;
	}
	return e.m[1][0];
} 

int main()
{
	long long n,m,c;
	cin>>n>>m;
	c=gcd(n,m);
	cout<<f(c)<<endl; 
	return 0;
} 
```

